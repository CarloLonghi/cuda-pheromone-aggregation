# Table of contents:
1. [Introduction](#introduction)
2. [Installation](#installation)
3. [CLion Integration](#clion-integration)
 
# Introduction

### Code logic 
The simulation tries to reproduce the behavior of a group of C. elegans moving in an environment while performing chemotaxis and responding to attractive and repulsive pheromones produced by the worms.

The `main.cu` contains the initialization, main loop and logging of the simulation. The initialization is done by reading the parameters through `argv`. The main loop is composed of moving the agents and logging their positions, speed, angle and state. Next, the grids relative to the chemicals are updated, if present, and logged as well. Finally, the logged data is saved to a `agents_all_data.json` file. In the following, I describe the headers.

The movement of the agents is modeled in `agent_update.h` as a run-and-tumble model. The tumble rate, in absence of stimuli, has been tuned to reproduce the mean-squared-displacement measured from C. elegans videos. The agents sense the potential (a combination of chemotactic odour, attractive and repulsive pheromone) in the position of the head and of the tail, sampling, in this way, the local gradient. The chemotactic movement, up the gradient, is modeled using a sigmoid function to calculate the tumble rate, as in Pierce-Shimomura, 1999. The angle resulting from the tumble is random within [0, 360].
The movement of the agents during the runs is affected by the alignment, attraction and repulsion forces produced by the neighbors, as in Sugi, 2019. if the distance D from a neighbor is less than `REPULSION_RANGE`, the agent feels a repulsive force from the neighbor. If, instead, D is more that `REPULSION_RANGE` but less than `ALIGNMENT_RANGE`, the agent feels the alignment and attractive forces. The alignment considere here is a nematic alignment. The alignment force is also modulated by a measure of the general alignment of the neighbors of the worm: if all the neighbors are aligned, the agent will align with them, if, instead, they are not aligned, the agent will slow down. The slow down effect is used to model the behavior of the worms in an aggregate.

`gaussian_odour.h`: calculates the concentration of odor based on a Gaussian diffusion model.

`logging.h`: saves all parameters and data generated by the execution of the code to a `.json`. The main function to look at is `saveAllDataToJSON`.

`init_env.h`: contains the structs and the initialisation of the agents, of the grids and of the sub-states.

`numeric_functions.h`: a collection of functions for the numerical solution of PDEs.

`parameters.h`: all the parameters of the simulation. 

`update_matrices.h`: functions that update the grids of chemical odor and pheromones, together with the grid of potentials.


### Parameters 

- `NN`	: quantization of the environment for the finite difference scheme; higher than 256 doesn't work well, needs optimisation of the block size of CUDA
- `WIDTH`	: width of the environment in mm
- `HEIGHT`: height of the environment in mm
- `SEED` 	: ideally, seed for all the random number generators; realistically, only used in a couple of functions, should be put everywhere.
- `WORM_COUNT`: number of agents
- `TIME`: duration of the simulation in seconds
- `DT`: time interval, used for the Euler scheme together with finite difference
- `N_STEPS`: number of time steps of the simulation, calculated from `TIME` and `DT`
- `LOGGING_INTERVAL`: the number of time steps separating the logging of grids, useful to save space and time
- `DEBUG`: adds some prints
- `ENABLE_RANDOM_INITIAL_POSITIONS`: tells the program if the agents positions should be at random or within some initial area
- `INITIAL_AREA_SIZE`: if above is false, this is the radius of the initial area
- `LOG_POTENTIAL`: unused, tells the program whether to log the grid of potentials every `LOGGING_INTERVAL` time step(s)
- `LOG_PHEROMONES`: unused, tells the program whether to log the grids of attractive and repulsive pheromones every `LOGGING_INTERVAL` time step(s)
- `LOG_AGENT_COUNT_GRID`: unused, tells the program whether to log the grid with the number of agents within each cell every `LOGGING_INTERVAL` time step(s)
- `LOG_GENERIC_TARGET_DATA`: tells the program whether to log the agents' data (position, angle, speed, sub-states and other parameters)
- `LOG_POSITIONS, LOG_ANGLES, LOG_VELOCITIES`: tells the program whether to log, respectively, position, angle and speed of every agent at every timestep
- `BODY_LENGTH`: length of the worms in the simulation
- `SPEED`: initial speed of an agent
- `MAX_CONCENTRATION`: initial and maximum concentration of the pheromones
- `ALIGNMENT_RADIUS`: radius for the alignment and attraction forces
- `REPULSION_RADIUS`: radius for the repulsion forces
- `CLUSTERING_RADIUS`: radius used to measure the clustering descriptor at the end of the simulation
- `NEIGHBOR_RADIUS`: radius used to measure the neighbor descriptor at the end of the simulation
- `MSD_WINDOW`: time window used to measure the MSD
- `SIGMA`: standard deviation of the white perceptual noise
- `ENVIRONMENTAL_NOISE`: standard deviation of the white environmental noise
- `SENSING_NOISE`: standard deviation of the white sensing noise
- `MU_X, MU_Y`: initial spot for the odor diffusion
- `DIFFUSION_CONSTANT`: odor diffusion constant
- `BLOCK_SIZE`: size of a CUDA block
- `CELL_SIZE`: size of the cell for the uniform grid partitioning
- `GRID_DIM_X, GRID_DIM_Y`: number of cells for the uniform grid partitioning

### Visualization

The simulator does not support real-time simulation, it only writes the history of "what happened" to a json. We provide a simple example Python implementation of a video renderer for the simulator in the visualization/video_maker.py script


# Installation

The following guide is written for Nobara 40, similar steps are to be executed on other Linux distros. I do not grant support for Windows/MacOS.

## Prerequisites 

Ensure you have the following software installed before proceeding:
- **CUDA Toolkit**: [12.3](https://developer.nvidia.com/cuda-12-3-0-download-archive)
- **GCC**: 11.4.0 (I recommend installing [Homebrew for Linux](https://docs.brew.sh/Homebrew-on-Linux)
## Setting Up Environment Variables

### Step 1: Verify Installed Versions 

You can verify the installed versions of `gcc` and `nvcc` using the following commands:

```bash
gcc --version
nvcc --version
```

Make sure the versions match the ones required for the project.

### Step 2: Setting the Environment Variables

Add the following lines to your shell configuration file (e.g., `.bashrc`, `.zshrc`) to set the required environment variables:

```bash
# Set environment variables for GCC and NVCC
export PATH=/usr/local/cuda-X.X/bin:$PATH  # Update with the correct CUDA version
export LD_LIBRARY_PATH=/usr/local/cuda-X.X/lib64:$LD_LIBRARY_PATH
export CC=/usr/bin/gcc-X.X                 # Update with your GCC path and version
export CXX=/usr/bin/g++-X.X                # Update with your G++ path and version
```

After modifying the file, apply the changes by running:

```bash
source ~/.bashrc  # or ~/.zshrc depending on your shell
```

### Step 3: Verify the Setup

To confirm that the environment variables are set correctly, run:

```bash
echo $PATH
echo $LD_LIBRARY_PATH
echo $CC
echo $CXX
```

### Step 4: Compiling the CUDA Simulator

Once the environment is configured, compile the CUDA simulator by navigating to the project directory and running the following command:

```bash
nvcc main.cu -o main -lm -lstdc++ --expt-relaxed-constexpr
```

# CLion Integration
In the following `cuda_dir` refers to the NVCC from CUDA Toolkit v12.3 insallation directory, which on most Linux distributions is installed in , while `gcc_dir` refers to the directory where GCC v11.4 is installed. On most Linux systems, the former is something like `/usr/local/cuda-12.3/bin/nvcc`, while the latter, if installed through Homebrew looks like `/home/linuxbrew/.linuxbrew/opt/gcc@11/bin/`.
If you are using CLion, you can build and run the project by accessing `Settings > Build, Execution, Deployment > Toolchains` and setting the "C Compiler" and "C++ Compiler" to the binaries of the respective compilers, which are in the `gcc_dir` and named `gcc-11` and `g++11` respectivly. Then, go to `Settings > Build, Execution, Deployment > CMake` and add the following CMake options: `-DCMAKE_CUDA_COMPILER=cuda_dir  -DCMAKE_CUDA_FLAGS="--compiler-bindir=gcc_dir/gcc-11"`. Now you should be able to build and execute the project.



